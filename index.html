<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sci-Fi Finance HUD</title>
  
  <style>
    /* --- 1. CORE VARIABLES --- */
    :root {
      --bg-color: #191919;
      --card-bg: #111111; 
      
      --neon-white: #ffffff;
      --neon-green: #00ff66;
      --neon-red: #ff0044;
      --neon-yellow: #ffcc00;
      
      --text-main: #e2e8f0;
      --text-gray: #7a8a9e;
      --sub-green: #6ee7b7; 
      --sub-red: #fca5a5;
    }

    @property --neon-color { syntax: '<color>'; inherits: true; initial-value: transparent; }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background-color: var(--bg-color);
      color: var(--text-main);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 30px;
      overflow-x: hidden;
    }

    /* --- 2. LAYOUT (Strict 1:3 Ratio) --- */
    .dashboard-layout {
      display: grid;
      grid-template-columns: 1fr 3fr; 
      gap: 30px;
      width: 100%;
      max-width: 1800px;
      margin: 0 auto;
      height: calc(100vh - 60px);
    }

    .left-column {
      display: grid;
      grid-template-rows: repeat(4, 1fr);
      gap: 25px;
      height: 100%;
      min-width: 0; 
    }

    /* --- 3. LEFT CARDS (Animated Borders & Themes) --- */
    .card-wrapper {
      position: relative; padding: 2px; border-radius: 8px;
      background: rgba(255,255,255,0.05); overflow: hidden;
      display: flex; flex-direction: column; z-index: 1; height: 100%;
      --neon-color: var(--neon-white); 
    }
    .card-wrapper::before {
      content: ''; position: absolute; top: -100%; left: -100%; width: 300%; height: 300%;
      background: conic-gradient(transparent, transparent, var(--neon-color), transparent, transparent);
      animation: rotate-border 4s linear infinite; z-index: -1;
    }
    @keyframes rotate-border { 100% { transform: rotate(360deg); } }

    .hud-card {
      background: var(--card-bg); border-radius: 6px; padding: 1.2vw 1.5vw; 
      display: flex; flex-direction: column; justify-content: space-between;
      position: relative; height: 100%; z-index: 2; box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
    }

    .text-up, .text-down { opacity: 0.85; font-weight: 600; }
    .text-up { color: var(--sub-green); text-shadow: 0 0 4px rgba(110, 231, 183, 0.2); }
    .text-down { color: var(--sub-red); text-shadow: 0 0 4px rgba(252, 165, 165, 0.2); }
    .text-gray { color: var(--text-gray); }

    .hud-header { display: flex; justify-content: space-between; align-items: center; }
    .hud-title {
      font-size: clamp(0.75rem, 1vw, 0.95rem); letter-spacing: 2px; font-weight: 700; text-transform: uppercase;
      color: var(--neon-color); text-shadow: 0 0 10px var(--neon-color);
      display: flex; align-items: baseline; flex-wrap: wrap;
    }
    .timeframe { font-size: 0.65em; color: var(--text-gray); text-shadow: none; letter-spacing: 1px; margin-left: 8px; font-weight: 400; }
    
    .hud-icon {
      color: var(--neon-color); filter: drop-shadow(0 0 5px var(--neon-color));
      width: clamp(18px, 1.5vw, 24px); height: clamp(18px, 1.5vw, 24px);
    }

    .hud-number-box {
      background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 4px;
      padding: 0.8vw 1.2vw; margin: auto 0; display: flex; justify-content: space-between; align-items: center;
    }
    .currency { font-size: clamp(1rem, 1.5vw, 1.5rem); opacity: 0.8; font-weight: 600; color: var(--neon-color); }
    .amount {
      font-size: clamp(1.5rem, 2.5vw, 2.3rem); font-weight: 700; letter-spacing: -1px; 
      text-align: right; width: 100%; font-variant-numeric: tabular-nums; 
      color: var(--neon-color); text-shadow: 0 0 15px var(--neon-color);
    }
    .hud-footer { display: flex; justify-content: space-between; font-size: clamp(0.65rem, 0.8vw, 0.85rem); font-weight: 600; }

    /* Themes */
    .theme-white { --neon-color: var(--neon-white); }
    .theme-white .hud-card { animation: breath-white 3s ease-in-out infinite; }
    .theme-white .amount, .theme-white .hud-title { animation: breath-white-text 3s ease-in-out infinite; }
    @keyframes breath-white {
      0%, 100% { box-shadow: 0 0 15px rgba(255,255,255,0.1), inset 0 0 15px rgba(255,255,255,0.05); background: rgba(17, 17, 17, 1); }
      50% { box-shadow: 0 0 80px rgba(255,255,255,0.6), inset 0 0 40px rgba(255,255,255,0.25); background: rgba(25, 25, 25, 1); }
    }
    @keyframes breath-white-text {
      0%, 100% { text-shadow: 0 0 10px rgba(255,255,255,0.4); }
      50% { text-shadow: 0 0 30px rgba(255,255,255,1), 0 0 10px rgba(255,255,255,0.8); }
    }

    .theme-green { --neon-color: var(--neon-green); }
    .theme-red { --neon-color: var(--neon-red); }

    .pulse-yg { animation: pulse-color-yg 3s infinite ease-in-out; }
    @keyframes pulse-color-yg { 0%, 100% { --neon-color: var(--neon-yellow); } 50% { --neon-color: var(--neon-green); } }
    .pulse-yr { animation: pulse-color-yr 3s infinite ease-in-out; }
    @keyframes pulse-color-yr { 0%, 100% { --neon-color: var(--neon-yellow); } 50% { --neon-color: var(--neon-red); } }

    /* SVG Animations */
    .icon-diamond { animation: spin-3d 3s linear infinite; }
    @keyframes spin-3d { 0% { transform: perspective(400px) rotateY(0deg); } 100% { transform: perspective(400px) rotateY(360deg); } }
    .wave-group { animation: slide-wave 1.5s linear infinite; }
    @keyframes slide-wave { 0% { transform: translateX(0); } 100% { transform: translateX(-24px); } }
    .shoot-up-group { animation: shoot-up 1.5s infinite linear; }
    @keyframes shoot-up { 0% { transform: translateY(18px); opacity: 0; } 20% { opacity: 1; } 80% { opacity: 1; } 100% { transform: translateY(-18px); opacity: 0; } }
    .shoot-down-group { animation: shoot-down 1.5s infinite linear; }
    @keyframes shoot-down { 0% { transform: translateY(-18px); opacity: 0; } 20% { opacity: 1; } 80% { opacity: 1; } 100% { transform: translateY(18px); opacity: 0; } }

    /* Grid Arrows Animation */
    .anim-up { display: inline-block; animation: grid-shoot-up 1.5s infinite linear; }
    .anim-down { display: inline-block; animation: grid-shoot-down 1.5s infinite linear; }
    @keyframes grid-shoot-up { 0% { transform: translateY(5px); opacity: 0; } 20% { opacity: 1; } 80% { opacity: 1; } 100% { transform: translateY(-5px); opacity: 0; } }
    @keyframes grid-shoot-down { 0% { transform: translateY(-5px); opacity: 0; } 20% { opacity: 1; } 80% { opacity: 1; } 100% { transform: translateY(5px); opacity: 0; } }

    /* --- 4. RIGHT COLUMN (CHARTS & GRIDS) --- */
    .right-column {
      display: flex; flex-direction: column; gap: 30px; height: 100%; min-width: 0;
    }
    
    .chart-box {
      flex: 1; 
      background: var(--card-bg); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 8px;
      padding: 20px; display: flex; flex-direction: column;
      position: relative; overflow: hidden; box-shadow: inset 0 0 40px rgba(0,0,0,0.6);
    }

    .chart-box::before, .chart-box::after {
      content: ''; position: absolute; width: 20px; height: 20px; pointer-events: none; z-index: 10;
    }
    .chart-box::before { top: 0; left: 0; border-top: 2px solid; border-left: 2px solid; border-color: rgba(255,255,255,0.3); }
    .chart-box::after { bottom: 0; right: 0; border-bottom: 2px solid; border-right: 2px solid; border-color: rgba(255,255,255,0.3); }

    #chart-header-nw {
      font-size: 0.9rem; letter-spacing: 4px; font-weight: 700; text-transform: uppercase;
      margin-bottom: 15px; position: relative; z-index: 10;
      color: var(--neon-white); text-shadow: 0 0 10px rgba(255,255,255,0.4);
      transition: opacity 0.4s ease, color 0.4s ease, text-shadow 0.4s ease;
    }

    .chart-header {
      font-size: 0.9rem; letter-spacing: 4px; font-weight: 700; text-transform: uppercase;
      margin-bottom: 15px; position: relative; z-index: 10; color: var(--text-gray);
    }

    /* Top Chart Canvas */
    .canvas-container { flex: 1; width: 100%; position: relative; }
    canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

    /* Bottom 12-Month Grid */
    .history-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 40px; 
      flex: 1; overflow: hidden;
    }
    .history-col {
      display: flex; flex-direction: column; justify-content: space-between; height: 100%;
    }
    .history-row {
      display: grid; grid-template-columns: 60px 1fr 1fr 1fr; gap: 10px; align-items: center;
      background: rgba(0,0,0,0.3); padding: 8px 12px; border-radius: 4px; 
      border-left: 2px solid rgba(255,255,255,0.1);
      transition: background 0.3s;
    }
    .history-row:hover { background: rgba(255,255,255,0.05); }

    .h-month { font-weight: 700; color: var(--text-gray); font-size: 0.85rem; letter-spacing: 1px; }
    
    .h-box {
      font-family: 'Segoe UI', monospace; font-size: 0.85rem; font-weight: 600;
      display: flex; align-items: center; justify-content: flex-end; /* Robust Flex Alignment */
      min-height: 32px; /* Forcing flawless alignment regardless of empty contents */
      padding: 0 10px; border-radius: 3px; background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.02);
      color: var(--text-main); 
    }
    
    /* Universally gray bottoms for Inc, Exp, and Zero Cashflow */
    .h-inc, .h-exp, .h-flow-zero { box-shadow: inset 0 -2px 0 rgba(255,255,255,0.2); }
    
    .h-flow-pos { color: var(--neon-green); text-shadow: 0 0 5px rgba(0,255,102,0.4); box-shadow: inset 0 -2px 0 rgba(0,255,102,0.5); }
    .h-flow-neg { color: var(--neon-red); text-shadow: 0 0 5px rgba(255,0,68,0.4); box-shadow: inset 0 -2px 0 rgba(255,0,68,0.5); }

    /* Loader */
    #loader {
      position: fixed; inset: 0; background: var(--bg-color); z-index: 9999;
      display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.4s;
    }
    .loader-ring {
      width: 45px; height: 45px; border: 2px solid rgba(255,255,255,0.1); border-top-color: var(--neon-white);
      border-radius: 50%; animation: spin 1s infinite linear;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

  </style>
</head>
<body>

  <!-- Loading Screen -->
  <div id="loader">
    <div class="loader-ring"></div>
    <div style="margin-top:20px; color:var(--text-gray); font-size:0.85rem; letter-spacing:4px; font-weight: 600;">LOADING TELEMETRY...</div>
  </div>

  <div class="dashboard-layout">
    
    <!-- LEFT COLUMN -->
    <div class="left-column">
      
      <!-- 1. BALANCE -->
      <div class="card-wrapper theme-white">
        <div class="hud-card">
          <div class="hud-header">
            <div class="hud-title">BALANCE</div>
            <svg class="hud-icon icon-diamond" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polygon points="12 2 2 7 12 22 22 7 12 2"></polygon>
              <polyline points="2 7 12 12 22 7"></polyline>
              <line x1="12" y1="22" x2="12" y2="12"></line>
            </svg>
          </div>
          <div class="hud-number-box">
            <div class="currency">৳</div>
            <div class="amount" id="val-bal">0</div>
          </div>
          <div class="hud-footer text-gray">
            <div>NET WORTH: <span style="color: var(--neon-white); opacity: 1;" id="lbl-net">...</span></div>
            <div>DEBT: <span style="color: var(--neon-white); opacity: 1;" id="lbl-debt">...</span></div>
          </div>
        </div>
      </div>

      <!-- 2. CASHFLOW -->
      <div class="card-wrapper" id="wrapper-flow">
        <div class="hud-card">
          <div class="hud-header">
            <div class="hud-title">CASHFLOW <span class="timeframe">(LAST 30 DAYS)</span></div>
            <svg class="hud-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" overflow="hidden">
              <g class="wave-group"><path d="M 0 12 Q 6 2, 12 12 T 24 12 Q 30 2, 36 12 T 48 12"></path></g>
            </svg>
          </div>
          <div class="hud-number-box">
            <div class="currency">৳</div>
            <div class="amount" id="val-flow">0</div>
          </div>
          <div class="hud-footer">
            <div class="text-gray">vs prev month: <span id="flow-prev">...</span></div>
            <div class="text-gray">vs last 6M: <span id="flow-avg">...</span></div>
          </div>
        </div>
      </div>

      <!-- 3. INCOME -->
      <div class="card-wrapper theme-green">
        <div class="hud-card">
          <div class="hud-header">
            <div class="hud-title">INCOME <span class="timeframe">(LAST 30 DAYS)</span></div>
            <svg class="hud-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" overflow="hidden">
              <g class="shoot-up-group"><line x1="12" y1="24" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></g>
            </svg>
          </div>
          <div class="hud-number-box">
            <div class="currency">৳</div>
            <div class="amount" id="val-inc">0</div>
          </div>
          <div class="hud-footer">
            <div class="text-gray">vs prev month: <span id="inc-prev">...</span></div>
            <div class="text-gray">vs last 6M: <span id="inc-avg">...</span></div>
          </div>
        </div>
      </div>

      <!-- 4. EXPENSE -->
      <div class="card-wrapper theme-red">
        <div class="hud-card">
          <div class="hud-header">
            <div class="hud-title">EXPENSE <span class="timeframe">(LAST 30 DAYS)</span></div>
            <svg class="hud-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" overflow="hidden">
              <g class="shoot-down-group"><line x1="12" y1="0" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></g>
            </svg>
          </div>
          <div class="hud-number-box">
            <div class="currency">৳</div>
            <div class="amount" id="val-exp">0</div>
          </div>
          <div class="hud-footer">
            <div class="text-gray">vs prev month: <span id="exp-prev">...</span></div>
            <div class="text-gray">vs last 6M: <span id="exp-avg">...</span></div>
          </div>
        </div>
      </div>

    </div>

    <!-- RIGHT COLUMN -->
    <div class="right-column">
      
      <!-- TOP HALF: 60-Second Loop Sparkline Chart -->
      <div class="chart-box">
        <div id="chart-header-nw">12-MONTH BALANCE TREND</div>
        <div class="canvas-container">
          <canvas id="canvas-nw"></canvas>
        </div>
      </div>

      <!-- BOTTOM HALF: 12-Month History Grid -->
      <div class="chart-box">
        <div class="chart-header">12-MONTH CASHFLOW HISTORY</div>
        <div class="history-grid" id="history-grid">
          <!-- Grid rows injected via JS -->
        </div>
      </div>

    </div>

  </div>

  <script>
    /** --- 1. LEFT CARD HUD ENGINE --- */
    class CyberScramble {
      constructor(elementId) { this.element = document.getElementById(elementId); this.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*X"; }
      run(targetValue, isNegative = false) {
        const valStr = Math.abs(targetValue).toLocaleString('en-US');
        const finalStr = (isNegative ? "-" : "") + valStr;
        let iteration = 0; clearInterval(this.interval);
        this.interval = setInterval(() => {
          this.element.innerText = finalStr.split("").map((letter, index) => {
            if (letter === "," || letter === "-") return letter;
            if (index < iteration) return finalStr[index]; 
            return this.chars[Math.floor(Math.random() * this.chars.length)]; 
          }).join("");
          if (iteration >= finalStr.length) { clearInterval(this.interval); this.element.innerText = finalStr; }
          iteration += 1 / 4; 
        }, 30);
      }
    }

    function getStatHTML(current, previous, isExpense = false) {
      if (!previous || previous === 0) return `<span class="text-gray">0%</span>`;
      const diff = current - previous;
      const pct = Math.abs((diff / Math.abs(previous)) * 100).toFixed(0);
      const isGood = isExpense ? diff < 0 : diff >= 0; 
      const arrow = diff >= 0 ? '▲' : '▼';
      const colorClass = isGood ? 'text-up' : 'text-down';
      return `<span class="${colorClass}">${arrow}${pct}%</span>`;
    }

    // Advanced Formatting (Maintains strict 1 decimal place for thousands)
    function shortFmt(num) {
      const abs = Math.abs(num);
      const sign = num < 0 ? '-' : '';
      if (abs >= 1000000) return sign + (abs / 1000000).toFixed(2) + 'M';
      if (abs >= 1000) return sign + (abs / 1000).toFixed(1) + 'K';
      return sign + abs;
    }

    function fullFmt(num) {
      return Math.abs(num).toLocaleString('en-US');
    }

    /** --- 2. TOP CHART: 60-SEC LOOP SMOOTH MORPHING SPARKLINE --- */
    class SparklineChart {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.data =[];
        this.points =[]; 
        
        // Loop State Configuration (Total 60,000ms / 60s loop)
        this.states =[
          { key: 'balance', label: '12-MONTH BALANCE TREND', color: {r:255,g:255,b:255}, shadow: 'rgba(255,255,255,0.4)', duration: 30000 },
          { key: 'income', label: '12-MONTH INCOME TREND', color: {r:0,g:255,b:102}, shadow: 'rgba(0,255,102,0.4)', duration: 10000 },
          { key: 'expense', label: '12-MONTH EXPENSE TREND', color: {r:255,g:0,b:68}, shadow: 'rgba(255,0,68,0.4)', duration: 10000 },
          { key: 'cashflow', label: '12-MONTH CASHFLOW TREND', color: {r:255,g:204,b:0}, shadow: 'rgba(255,204,0,0.4)', duration: 10000 }
        ];
        
        this.curState = 0;
        this.timeInState = 0;
        this.lastTime = 0;
        this.morphProgress = 1;
        this.textOpacity = 1;
        this.isMorphing = false;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        requestAnimationFrame((t) => this.tick(t));
      }

      resize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.ctx.scale(dpr, dpr);
        this.w = rect.width;
        this.h = rect.height;
        if(this.data.length > 0) this.updateTargets(true); // Snap to new dimensions immediately
      }

      loadData(chartData) {
        this.data = chartData.slice(-12);
        this.updateTargets(true); 
      }

      updateTargets(snap = false) {
        if (this.data.length === 0) return;
        const key = this.states[this.curState].key;
        
        // Safely extract values, converting undefined/null to 0
        const vals = this.data.map(d => d[key] || 0);
        
        const minVal = Math.min(...vals);
        const maxVal = Math.max(...vals);
        const range = (maxVal - minVal) || 1; // Prevent division by zero
        
        const padTop = 35;
        const padBot = 25;
        const activeH = this.h - padTop - padBot;
        const stepX = this.w / Math.max(1, this.data.length - 1);
        
        for (let i = 0; i < this.data.length; i++) {
            let px = i * stepX;
            if (i === 0) px += 15;
            if (i === this.data.length - 1) px -= 15;
            
            const py = padTop + activeH - (((vals[i]) - minVal) / range) * activeH;
            
            if (snap || this.points.length !== this.data.length) {
                // Initialize points directly to their correct visual positions
                this.points[i] = { x: px, y: py, startY: py, targetY: py, val: vals[i], label: this.data[i].chartLabel };
            } else {
                // Record current position as start, assign new target
                this.points[i].x = px;
                this.points[i].startY = this.points[i].y; 
                this.points[i].targetY = py;
                this.points[i].val = vals[i];
            }
        }
      }

      updateHeader() {
         const el = document.getElementById('chart-header-nw');
         const state = this.states[this.curState];
         el.style.opacity = 0;
         setTimeout(() => {
             el.innerText = state.label;
             el.style.color = `rgb(${state.color.r},${state.color.g},${state.color.b})`;
             el.style.textShadow = `0 0 10px ${state.shadow}`;
             el.style.opacity = 1;
         }, 400); // 400ms matches the transition-out timing in CSS
      }

      easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      lerpColor(c1, c2, t) {
         const r = Math.round(c1.r + (c2.r - c1.r) * t);
         const g = Math.round(c1.g + (c2.g - c1.g) * t);
         const b = Math.round(c1.b + (c2.b - c1.b) * t);
         return `rgb(${r},${g},${b})`;
      }

      tick(time) {
        requestAnimationFrame((t) => this.tick(t));
        if (!this.lastTime) this.lastTime = time;
        // Cap Delta-Time (dt) to 50ms (simulates ~20fps drop). 
        const dt = Math.min(time - this.lastTime, 50); 
        this.lastTime = time;
        
        if (this.data.length === 0) return;
        
        this.timeInState += dt;
        
        // --- TIMING FIX ---
        // Lock the duration evaluation to the OUTGOING state during the morph.
        // This prevents the timeline thresholds from snapping mid-animation.
        const stateIndex = (this.isMorphing && this.prevState !== undefined) ? this.prevState : this.curState;
        const stateDur = this.states[stateIndex].duration;
        
        // Logical Timeline Bounds
        const fadeOutStart = stateDur - 500;
        const morphStart = stateDur;
        const morphEnd = stateDur + 1000;
        const fadeInEnd = stateDur + 1500;
        
        // Evaluate state strictly sequentially from the end to the beginning 
        if (this.timeInState >= fadeInEnd) {
            this.timeInState -= fadeInEnd; // Retain remainder for precise looping
            this.isMorphing = false;
            this.textOpacity = 1;
            this.morphProgress = 1;
        } else if (this.timeInState >= morphEnd) {
            this.morphProgress = 1;
            this.textOpacity = Math.min(1, Math.max(0, (this.timeInState - morphEnd) / 500));
        } else if (this.timeInState >= morphStart) {
            this.textOpacity = 0;
            // Initiate Morph triggers exactly once when crossing this threshold
            if (!this.isMorphing) {
                this.isMorphing = true;
                this.prevState = this.curState;
                this.curState = (this.curState + 1) % this.states.length;
                this.updateTargets();
                this.updateHeader();
            }
            const rawP = (this.timeInState - morphStart) / 1000;
            this.morphProgress = this.easeInOutCubic(Math.min(1, Math.max(0, rawP)));
        } else if (this.timeInState >= fadeOutStart) {
            this.textOpacity = Math.min(1, Math.max(0, 1 - (this.timeInState - fadeOutStart) / 500));
        } else {
            this.textOpacity = 1;
            this.morphProgress = 1;
        }
        
        this.draw();
      }

      draw() {
         this.ctx.clearRect(0, 0, this.w, this.h);
         
         // 1. Calculate Morphing Y positions dynamically
         for(let p of this.points) {
            p.y = p.startY + (p.targetY - p.startY) * this.morphProgress;
         }
         
         const curDef = this.states[this.curState];
         let strokeColorStr = `rgb(${curDef.color.r},${curDef.color.g},${curDef.color.b})`;
         
         // Interpolate Line Color during Morph Transition
         if (this.isMorphing && this.prevState !== undefined) {
             const prev = this.states[this.prevState];
             strokeColorStr = this.lerpColor(prev.color, curDef.color, this.morphProgress);
         }
         
         const padBot = 25;
         const padTop = 35;
         
         // 2. Draw Smooth Bezier Curve Line
         this.ctx.beginPath();
         this.ctx.moveTo(this.points[0].x, this.points[0].y);
         for(let i=0; i<this.points.length - 1; i++) {
             const xm = (this.points[i].x + this.points[i+1].x)/2;
             this.ctx.bezierCurveTo(xm, this.points[i].y, xm, this.points[i+1].y, this.points[i+1].x, this.points[i+1].y);
         }
         this.ctx.strokeStyle = strokeColorStr;
         this.ctx.lineWidth = 3;
         this.ctx.shadowColor = strokeColorStr;
         this.ctx.shadowBlur = 12;
         this.ctx.stroke();
         this.ctx.shadowBlur = 0;
         
         // 3. Draw Subdued Fill Gradient matching line color
         const fillPath = new Path2D();
         fillPath.moveTo(this.points[0].x, this.h - padBot);
         fillPath.lineTo(this.points[0].x, this.points[0].y);
         for(let i=0; i<this.points.length - 1; i++) {
             const xm = (this.points[i].x + this.points[i+1].x)/2;
             fillPath.bezierCurveTo(xm, this.points[i].y, xm, this.points[i+1].y, this.points[i+1].x, this.points[i+1].y);
         }
         fillPath.lineTo(this.points[this.points.length-1].x, this.h - padBot);
         fillPath.closePath();
         
         const fillBase = strokeColorStr.replace('rgb', 'rgba').replace(')', ', 0.2)');
         const grad = this.ctx.createLinearGradient(0, padTop, 0, this.h - padBot);
         grad.addColorStop(0, fillBase);
         grad.addColorStop(1, 'rgba(0,0,0,0)');
         this.ctx.fillStyle = grad;
         this.ctx.fill(fillPath);
         
         // 4. Draw Glowing Data Dots & Text (Applying Alpha Fade dynamically)
         this.ctx.textAlign = 'center';
         this.points.forEach((p) => {
             // Dots
             this.ctx.beginPath();
             this.ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
             this.ctx.fillStyle = '#111';
             this.ctx.fill();
             this.ctx.lineWidth = 2;
             this.ctx.strokeStyle = strokeColorStr;
             this.ctx.stroke();
             
             // Dynamic opacity for the fade-out/fade-in animation
             this.ctx.globalAlpha = this.textOpacity;
             
             // Top Number (Uses explicit formatting 1500 -> 1.5K)
             this.ctx.fillStyle = '#ffffff';
             this.ctx.font = 'bold 12px "Segoe UI"';
             this.ctx.fillText(shortFmt(p.val), p.x, p.y - 12);
             
             // Bottom Month Text
             this.ctx.fillStyle = '#7a8a9e';
             this.ctx.font = '600 11px "Segoe UI"';
             this.ctx.fillText(p.label, p.x, this.h - 5);
             
             this.ctx.globalAlpha = 1.0; // Reset alpha for next render steps
         });
      }
    }

    /** --- 3. BOTTOM GRID: 12-MONTH HISTORY --- */
    function renderHistoryGrid(chartData) {
      const container = document.getElementById('history-grid');
      // Reverse array to ensure newest month (Current) is index 0
      const data =[...chartData.slice(-12)].reverse();
      
      const leftCol = data.slice(0, 6); 
      const rightCol = data.slice(6, 12);

      const buildRow = (d, isLatest) => {
        // Income & Expense (Values are colorless. Arrows render with color. Empty string if 0)
        let incHtml = d.income > 0 ? `<span style="color:var(--neon-green); margin-right: 5px;" class="${isLatest ? 'anim-up' : ''}">▲</span> ${fullFmt(d.income)}` : ``;
        let expHtml = d.expense > 0 ? `<span style="color:var(--neon-red); margin-right: 5px;" class="${isLatest ? 'anim-down' : ''}">▼</span> ${fullFmt(d.expense)}` : ``;
        
        let flowHtml = '';
        if (d.cashflow > 0) {
          flowHtml = `<div class="h-box h-flow-pos"><span style="margin-right: 5px;" class="${isLatest ? 'anim-up' : ''}">▲</span> ${fullFmt(d.cashflow)}</div>`;
        } else if (d.cashflow < 0) {
          flowHtml = `<div class="h-box h-flow-neg"><span style="margin-right: 5px;" class="${isLatest ? 'anim-down' : ''}">▼</span> ${fullFmt(Math.abs(d.cashflow))}</div>`;
        } else {
          // Exactly 0 = Colorless grey block with no arrow
          flowHtml = `<div class="h-box h-flow-zero">0</div>`;
        }

        return `
          <div class="history-row">
            <div class="h-month">${d.gridLabel}</div>
            <div class="h-box h-inc">${incHtml}</div>
            <div class="h-box h-exp">${expHtml}</div>
            ${flowHtml}
          </div>
        `;
      };

      let html = '<div class="history-col">';
      leftCol.forEach((d, i) => html += buildRow(d, i === 0)); // Pass 'true' for latest month index 0
      html += '</div><div class="history-col">';
      rightCol.forEach(d => html += buildRow(d, false)); // Right col is strictly older history
      html += '</div>';

      container.innerHTML = html;
    }


    /** --- 4. MAIN INITIALIZATION --- */
    async function init() {
      const display = {
        bal: new CyberScramble('val-bal'),
        flow: new CyberScramble('val-flow'),
        inc: new CyberScramble('val-inc'),
        exp: new CyberScramble('val-exp')
      };

      try {
        const res = await fetch('/api?t=' + Date.now());
        if (!res.ok) throw new Error("API Route failed");
        const data = await res.json();
        if(data.backendError) throw new Error(data.backendError);

        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').style.display = 'none', 400);

        // 1. HUD Updates
        const parsedBalance = Math.abs(data.summary.balance || 0);
        display.bal.run(parsedBalance, data.summary.balance < 0);
        document.getElementById('lbl-net').innerText = '৳' + Math.abs(data.summary.netWorth || 0).toLocaleString();
        document.getElementById('lbl-debt').innerText = '৳' + Math.abs(data.summary.totalDebt || 0).toLocaleString();

        const flowWrapper = document.getElementById('wrapper-flow');
        if (data.kpis.current.cashflow >= 0) flowWrapper.classList.add('pulse-yg');
        else flowWrapper.classList.add('pulse-yr');
        
        display.flow.run(data.kpis.current.cashflow, data.kpis.current.cashflow < 0);
        document.getElementById('flow-prev').innerHTML = getStatHTML(data.kpis.current.cashflow, data.kpis.last.cashflow, false);
        document.getElementById('flow-avg').innerHTML = getStatHTML(data.kpis.current.cashflow, data.kpis.averages.flow, false);

        display.inc.run(data.kpis.current.income);
        document.getElementById('inc-prev').innerHTML = getStatHTML(data.kpis.current.income, data.kpis.last.income, false);
        document.getElementById('inc-avg').innerHTML = getStatHTML(data.kpis.current.income, data.kpis.averages.inc, false);

        display.exp.run(data.kpis.current.expense);
        document.getElementById('exp-prev').innerHTML = getStatHTML(data.kpis.current.expense, data.kpis.last.expense, true);
        document.getElementById('exp-avg').innerHTML = getStatHTML(data.kpis.current.expense, data.kpis.averages.exp, true);

        // 2. Data Processing for Charts
        if (data.chartData && data.chartData.length > 0) {
            
            const monthNames =["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
            const dDate = new Date();
            let runningBal = parsedBalance;

            // Iterate backwards through chart data to calculate historic labels and balances
            for(let i = data.chartData.length - 1; i >= 0; i--) {
                data.chartData[i].chartLabel = monthNames[dDate.getMonth()];
                data.chartData[i].gridLabel = `${monthNames[dDate.getMonth()]}/${dDate.getFullYear().toString().slice(-2)}`;
                dDate.setMonth(dDate.getMonth() - 1);

                data.chartData[i].balance = runningBal;
                runningBal = runningBal - (data.chartData[i].cashflow || 0); 
            }
            
            const mainChart = new SparklineChart('canvas-nw');
            mainChart.loadData(data.chartData);

            renderHistoryGrid(data.chartData);
        }

      } catch (e) {
        console.error("System Error:", e);
        
        // MOCK DATA FALLBACK
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').style.display = 'none', 400);

        display.bal.run(1245000);
        document.getElementById('lbl-net').innerText = "৳1,233,000"; document.getElementById('lbl-debt').innerText = "৳12,000";
        document.getElementById('wrapper-flow').classList.add('pulse-yg'); display.flow.run(45200);
        document.getElementById('flow-prev').innerHTML = getStatHTML(45200, 30000, false); 
        document.getElementById('flow-avg').innerHTML = getStatHTML(45200, 50000, false); 
        display.inc.run(85000); display.exp.run(39800);
        document.getElementById('inc-prev').innerHTML = getStatHTML(85000, 80000, false); 
        document.getElementById('inc-avg').innerHTML = getStatHTML(85000, 70000, false); 
        document.getElementById('exp-prev').innerHTML = getStatHTML(39800, 50000, true); 
        document.getElementById('exp-avg').innerHTML = getStatHTML(39800, 30000, true); 

        // Generate 12-month mock dataset
        let mockData =[];
        let mockBal = 1245000; 
        const monthNames =["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
        const dDate = new Date();

        for (let i = 0; i < 12; i++) {
          let mockInc = 60000 + (Math.random() * 40000); 
          let mockExp = 30000 + (Math.random() * 50000); 
          // Inject an exact zero cashflow block to verify correct blank rendering
          if(i===5) { mockInc = 0; mockExp = 0; } 
          mockData.unshift({ income: mockInc, expense: mockExp, cashflow: mockInc - mockExp });
        }

        for (let i = mockData.length - 1; i >= 0; i--) {
          mockData[i].chartLabel = monthNames[dDate.getMonth()];
          mockData[i].gridLabel = `${monthNames[dDate.getMonth()]}/${dDate.getFullYear().toString().slice(-2)}`;
          dDate.setMonth(dDate.getMonth() - 1);
          
          mockData[i].balance = mockBal;
          mockBal = mockBal - mockData[i].cashflow;
        }

        const mainChart = new SparklineChart('canvas-nw');
        mainChart.loadData(mockData);

        renderHistoryGrid(mockData);
      }
    }

    window.onload = init;
  </script>
</body>
</html>
